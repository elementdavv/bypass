text := import("text")
brook := import("brook")
json := import("json")

dnsquery_handler := func(m){
    if m.domain == "example.com"{
        return {"block": true}
    }
    if m.domain == "example1.com"{
        return {"bypass": true}
    }
    if m.domain == "example2.com" {
        if m.type == "A" {
            return {ip: "10.211.1.76"}
        }
        if m.type == "AAAA" {
            return {"block": true}
        }
    }
    if m.domain == "dns.google" || m.type == "AAAA" {
        return {"block": true}
    }
    if text.has_suffix(m.domain, "facebook.com") ||
        text.has_suffix(m.domain, "fbcdn.net") ||
        text.has_suffix(m.domain, "facebook.net") ||
        text.has_suffix(m.domain, "akamaihd.net") ||
        text.has_suffix(m.domain, "thefacebook.com") ||
        text.has_suffix(m.domain, "tfbnw.net") ||
        text.has_suffix(m.domain, "messenger.com") ||
        text.has_suffix(m.domain, "fb.me") ||
        text.has_suffix(m.domain, "fbsbx.com") ||
        text.has_suffix(m.domain, "fb.com") ||
        text.has_suffix(m.domain, "whatsapp.net") ||
        text.has_suffix(m.domain, "whatsapp.com") ||
        text.has_suffix(m.domain, "instagram.com") ||
        text.has_suffix(m.domain, "akamai.net") ||
        text.has_suffix(m.domain, "apple.com") ||
        text.has_suffix(m.domain, "aaplimg.com") ||
        text.has_suffix(m.domain, "alibabadns.com") ||
        text.has_suffix(m.domain, "akamaiedge.net") ||
        text.has_suffix(m.domain, "apple-dns.net") ||
        text.has_suffix(m.domain, "akadns.net") ||
        text.has_suffix(m.domain, "cdninstagram.com") {
        return {"system": true}
    }
    // apple push
    l := [
        "apple.com",
        "icloud.com",
        "cdn-apple.com",
        "mzstatic.com",
        "entrust.net",
        "digicert.com",
        "verisign.net",
        "apple",
        "itunes-apple.com.akadns.net",
        "cdn-apple.com.akadns.net",
        "ks-cdn.com",
        "ksyuncdn.com",
        "cdn-apple.com.edgekey.net",
        "e2885.e9.akamaiedge.net",
        "apple.com.edgekey.net",
        "e2490.dscb.akamaiedge.net",
        "idms-apple.com.akadns.net",
        "apple.com.edgekey.net.globalredir.akadns.net",
        "e6858.dscx.akamaiedge.net",
        "ioshost.qtlcdn.com"
    ]
    for v in l {
        if text.has_suffix(m.domain, v) {
            return {"bypass": true}
        }
    }
}

address_handler := func(m) {
    if m.ipaddress && (m.ipaddress == "8.8.8.8:853" || m.ipaddress == "8.8.8.8:443" || m.ipaddress == "8.8.4.4:853" || m.ipaddress == "8.8.4.4:443" || m.ipaddress == "[2001:4860:4860::8888]:853" || m.ipaddress == "[2001:4860:4860::8888]:443" || m.ipaddress == "[2001:4860:4860::8844]:853" || m.ipaddress == "[2001:4860:4860::8844]:443") {
        return { "block": true }
    }
    if m.domainaddress && text.has_prefix(m.domainaddress, "dns.google:") {
        return { "block": true }
    }
    if m.ipaddress {
        r := brook.splithostport(m.ipaddress)
        if is_error(r) {
            return r
        }
        if r.host == "1.2.4.8" {
            return { "block": true }
        }
        s := brook.country(r.host)
        if s == "ZZ" || s == "CN" {
            return { "bypass": true }
        }
        // apple push
        if brook.cidrcontainsip("17.0.0.0/8", r.host) ||
            brook.cidrcontainsip("103.81.148.0/22", r.host) ||
            brook.cidrcontainsip("103.81.148.0/24", r.host) ||
            brook.cidrcontainsip("2620:149:a44::/48", r.host) ||
            brook.cidrcontainsip("2403:300:a42::/48", r.host) ||
            brook.cidrcontainsip("2403:300:a51::/48", r.host) ||
            brook.cidrcontainsip("2a01:b740:a42::/48", r.host) ||
            brook.cidrcontainsip("103.81.149.0/24", r.host) {
            return {"bypass": true}
        }
        return
    }
    if m.network == "tcp" && m.domainaddress {
        if m.domainaddress == "httpbin.org:80" {
            return {"mitm": true, "mitmprotocol": "http"}
        }
        if m.domainaddress == "httpbin.org:443" {
            return {"mitm": true, "mitmprotocol": "https", "mitmwithbody": true, "mitmautohandlecompress": true}
        }
        if m.domainaddress == "example3.com:80" {
            return {"ipaddress": "10.211.1.76:8080", "bypass": true, "mitm": true, "mitmprotocol": "http", "mitmwithbody": true, "mitmautohandlecompress": true}
        }
        if m.domainaddress == "myip.ipip.net:443" {
            return {"ipaddressfrombypassdns": "A", "bypass": true, "mitm": true, "mitmprotocol": "https", "mitmwithbody": true, "mitmautohandlecompress": true}
        }
        return
    }
    if m.network == "udp" && m.domainaddress {
        if m.domainaddress == "httpbin.org:443" {
            return { "block": true }
        }
        return
    }
}

httprequest_handler := func(request){
    if text.has_prefix(request["URL"], "http://httpbin.org") {
        response := {
            "StatusCode": 301,
            "Location": text.replace(request["URL"], "http://", "https://", 1)
        }
        return response
    }
    if request["URL"] == "https://httpbin.org/post" && request["Method"] == "POST" && request["Content-Type"] == "application/x-www-form-urlencoded" {
        request["User-Agent"] = "curl/7.79.1"
        request["Body"] = bytes("hello=world")
        return request
    }
    return request
}

httpresponse_handler := func(request, response){
    delete(response, "Alt-Svc") // Avoid upgrading to http3 from http1 or http2
    if text.has_prefix(request["URL"], "https://httpbin.org") && !text.has_prefix(request["URL"], "https://httpbin.org/stream/") && response["Content-Type"] == "application/json" {
        j := json.decode(response["Body"])
        j.origin = "M.A.R.S"
        response["Body"] = json.encode(j)
        return response
    }
    if text.has_prefix(request["URL"], "https://myip.ipip.net") {
        response["Body"] = bytes(text.split(string(response["Body"]), "IP")[0] + "来自: 火星")
        return response
    }
    return response
}

handler := func(){
    if in_dnsquery {
        return dnsquery_handler(in_dnsquery)
    }
    if in_address {
        return address_handler(in_address)
    }
    if in_httprequest && !in_httpresponse {
        return httprequest_handler(in_httprequest)
    }
    if in_httprequest && in_httpresponse {
        return httpresponse_handler(in_httprequest, in_httpresponse)
    }
}

out := handler()
